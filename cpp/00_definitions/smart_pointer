Smart pointer:
	A Smart pointer is a composition class that is designed to manage dynamically allocated memory and ensure that memory gets deleted when the 
	smart pointer object goes out of scope. (Relatedly, built-in pointers are sometimes called “dumb pointers” because they can’t clean up after 
	themselves).

std::auto_ptr:
	std::auto_ptr implements move semantics through the copy constructor and assignment operator, passing a std::auto_ptr by value to a function will 
	cause your resource to get moved to the function parameter (and be destroyed at the end of the function when the function parameters go out of scope).
	Then when you go to access your auto_ptr argument from the caller (not realizing it was transferred and deleted), you’re suddenly dereferencing a 
	null pointer. Crash!

	Second, std::auto_ptr always deletes its contents using non-array delete. This means auto_ptr won’t work correctly with dynamically allocated arrays,
	because it uses the wrong kind of deallocation. Worse, it won’t prevent you from passing it a dynamic array, which it will then mismanage, leading to memory leaks.

	Finally, auto_ptr doesn’t play nice with a lot of the other classes in the standard library, including most of the containers and algorithms. This occurs because those standard library classes assume that when they copy an item, it actually makes a copy, not a move.

	Because of the above mentioned shortcomings, std::auto_ptr has been deprecated in C++11, and it should not be used. In fact, std::auto_ptr is slated for complete removal from the standard library as part of C++17!

	Rule: std::auto_ptr is deprecated and should not be used. (Use std::unique_ptr or std::shared_ptr instead)

Move semantics:
	. Move semantics means the class will transfer ownership of the object rather than making a copy.
	. In C++11, the concept of “move” was formally defined, and “move semantics” were added to the language to properly 
	  differentiate copying from moving.

l-values:
	. It’s simplest to think of an l-value (also called a locator value) as a function or an object (or an expression that 
	  evaluates to a function or object). All l-values have assigned memory addresses.

	. “values that are suitable to be on the left-hand side of an assignment expression”. However, later, the const keyword was 
	   added to the language, and l-values were split into two sub-categories: modifiable l-values, which can be changed, and non-modifiable l-values, which are const.
	. An lvalue represents an object that occupies a location in memory. This means it has a memory address.
	. Named-objects are l-values.

r-values:
	. everything that is not an l-value.
	. This notably includes literals (e.g. 5), temporary values (e.g. x+1), and anonymous objects (e.g. Fraction(5, 2)). r-values 
	  are typically evaluated for their values, have expression scope (they die at the end of the expression they are in), and cannot be assigned to.
	. rvalue doesn't have a menmory address. A rvalue doesn't represent an object that occupies a location in memory.
	. Anonymous objects are r-values.

L-value references:
	. L-value references can only be initialized with modifiable l-values.
	. an l-value reference is created using a single ampersand.

R-value references:
	. An r-value reference is a reference that is designed to be initialized with an r-value (only).
	. R-value reference is created using a double ampersand.
	. R-value references have two properties that are useful. First, r-value references extend the lifespan of the object they are  
	  initialized with to the lifespan of the r-value reference (l-value references to const objects can do this too). Second, non-const r-value references allow you to modify the r-value!
	. R-value references are more often used as function parameters. This is most useful for function overloads when you want to have 
	  different behavior for l-value and r-value arguments.

	 Eg: int x{ 5 };
		int &lref{ x }; // l-value reference initialized with l-value x
		int &&rref{ 5 }; // r-value reference initialized with r-value 5

Move constructors and move assignment:
	Whereas the goal of the copy constructor and copy assignment is to make a copy of one object to another, the goal of the move constructor and move assignment is to move ownership of the resources from one object to another (which is much less expensive than making a copy).

std::move:
	In C++11, std::move is a standard library function that serves a single purpose -- to convert its argument into an r-value. We can pass an l-value to std::move, and it will return an r-value reference. std::move is defined in the utility header.

	std::move can be used whenever we want to treat an l-value like an r-value for the purpose of invoking move semantics instead of copy semantics.

std::unique_ptr:
	. std::unique_ptr is the C++11 replacement for std::auto_ptr. It should be used to manage any dynamically allocated object 
	  that is not shared by multiple objects. That is, std::unique_ptr should completely own the object it manages, not share that ownership
	  with other classes. std::unique_ptr lives in the <memory> header.
	  Eg: std::unique_ptr<Resource> res{ new Resource() };

	. std::unique_ptr has an overloaded operator* and operator-> that can be used to return the resource being managed. Operator* 
	  returns a reference to the managed resource, and operator-> returns a pointer.

	  eg:
	  	class Resource
		{
		public:
			Resource() { std::cout << "Resource acquired\n"; }
			~Resource() { std::cout << "Resource destroyed\n"; }
			friend std::ostream& operator<<(std::ostream& out, const Resource &res)
			{
				out << "I am a resource\n";
				return out;
			}
		};
		 
		int main()
		{
			std::unique_ptr<Resource> res{ new Resource{} };
		 
			if (res) // use implicit cast to bool to ensure res contains a Resource
				std::cout << *res << '\n'; // print the Resource that res is owning
			return 0;
		}


std::make_unique:
	C++14 comes with an additional function named std::make_unique(). This templated function constructs an object of the template type and initializes 
	it with the arguments passed into the function.

	Eg: std::unique_ptr<Fraction> f1{ std::make_unique<Fraction>(3, 5) };

	Use of std::make_unique() is optional, but is recommended over creating std::unique_ptr yourself. This is because code using std::make_unique is
	simpler, and it also requires less typing (when used with automatic type deduction). Furthermore it resolves an exception safety issue that can 
	result from C++ leaving the order of evaluation for function arguments unspecified.

	std::unique_ptr<Foo> f1(new Foo(10));
	std::unique_ptr<Foo> f2 = std::make_unique<Foo>(100);
	std::unique_ptr<Foo> f3 = std::move(f1);
	
	auto f1{std::make_unique<Resource>(5,8)};

get():
	To get a raw resource pointer from a std::unique_ptr.
	eg:
		void useResource(Resource *res)
		{
			if (res)
				std::cout << *res << '\n';
		}

		auto ptr{ std::make_unique<Resource>() };
 
		useResource(ptr.get()); // note: get() used here to get a pointer to the Resource

std::shared_ptr:
	Unlike std::unique_ptr, which is designed to singly own and manage a resource, std::shared_ptr is meant to solve the case where you need multiple
	smart pointers co-owning a resource.

	This means that it is fine to have multiple std::shared_ptr pointing to the same resource. Internally, std::shared_ptr keeps track of how many
	std::shared_ptr are sharing the resource. As long as at least one std::shared_ptr is pointing to the resource, the resource will not be deallocated,
	even if individual std::shared_ptr are destroyed. As soon as the last std::shared_ptr managing the resource goes out of scope (or is reassigned to 
	point at something else), the resource will be deallocated.

	Like std::unique_ptr, std::shared_ptr lives in the <memory> header.

	std::shared_ptr is designed for the case where you need multiple smart pointers co-managing the same resource. The resource will be deallocated when the last std::shared_ptr managing the resource is destroyed.

	Eg:
		Resource *res = new Resource;
		std::shared_ptr<Resource> ptr1(res);
		{
			std::shared_ptr<Resource> ptr2(ptr1); // create ptr2 directly from res (instead of ptr1)
			std::cout << "Killing one shared pointer\n";
		} // ptr2 goes out of scope here, and the allocated Resource is destroyed
		std::cout << "Killing another shared pointer\n";

	Inside the nested block, we use copy initialization (which is allowed with std::shared_ptr, since the resource can be shared) to create a second std::shared_ptr (ptr2) that points to the same Resource.

	Always make a copy of an existing std::shared_ptr if you need more than one std::shared_ptr pointing to the same resource.
	std::shared_ptr<Resource> ptr2(ptr1);
	
std::make_shared:
	Much like std::make_unique() can be used to create a std::unique_ptr in C++14, std::make_shared() can (and should) be used to make a std::shared_ptr. std::make_shared() is available in C++11.

Circular references:
	A Circular reference (also called a cyclical reference or a cycle) is a series of references where each object references the next, and the last 
	object references back to the first, causing a referential loop. The references do not need to be actual C++ references -- they can be pointers, 
	unique IDs, or any other means of identifying specific objects.

std::weak_ptr:
	. std::weak_ptr is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by std::shared_ptr. It 
	  must be converted to std::shared_ptr in order to access the referenced object.
	. std::weak_ptr was designed to solve the “cyclical ownership” problem
	. A std::weak_ptr is an observer -- it can observe and access the same object as a std::shared_ptr (or other std::weak_ptrs) but  
	  it is not considered an owner. Remember, when a std::shared pointer goes out of scope, it only considers whether other std::shared_ptr are 
	  co-owning the object. std::weak_ptr does not count.


	  class Person
	  {
		std::string m_name;
		//std::shared_ptr_ptr<Person> m_partner; //problem because it will create “cyclical ownership” problem
		std::weak_ptr<Person> m_partner; // note: This is now a std::weak_ptr
		public:
			Person(const std::string &name) : m_name(name)
			{
				std::cout << m_name << " created\n";
			}
			~Person()
			{
				std::cout << m_name << " destroyed\n";
			}
			friend bool partnerUp(std::shared_ptr<Person> &p1, std::shared_ptr<Person> &p2)
			{
				if (!p1 || !p2)
					return false;
		 
				p1->m_partner = p2;
				p2->m_partner = p1;
		 
				std::cout << p1->m_name << " is now partnered with " << p2->m_name << "\n";
		 
				return true;
			}
			const std::shared_ptr<Person> getPartner() const { return m_partner.lock(); } // use lock() to convert weak_ptr to shared_ptr
			const std::string& getName() const { return m_name; }
	};
 
	int main()
	{
		auto lucy = std::make_shared<Person>("Lucy");
		auto ricky = std::make_shared<Person>("Ricky");
	 
		partnerUp(lucy, ricky);
	 
		auto partner = ricky->getPartner(); // get shared_ptr to Ricky's partner
		std::cout << ricky->getName() << "'s partner is: " << partner->getName() << '\n';
	 
		return 0;
	}


Operations:
	get() : It will return the managed resource.
	release() : It will release the managed resource and return managed resource to you.
	reset(): The managed resource will be replaced by passed resource.
	swap(): It used to swap pointer pointed by two unique_ptr.
	get_deleter(): Returns the deleter object which would be used for destruction of the managed object.

	use_count(): returns the number of shared_ptr objects that manage the object.
	expired(): checks whether the referenced object was already deleted.
	lock(): creates a shared_ptr that manages the referenced object.
	owner_before: provides owner-based ordering of weak pointers

