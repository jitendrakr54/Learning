Function:
	. A function parameter (sometimes called a formal parameter) is a variable declared in the function declaration.
	  eg: 
	  	void foo(int x); // declaration (function prototype) -- x is a parameter
	. An argument (sometimes called an actual parameter) is the value that is passed to the function by the caller.
	  eg:	
		foo(6); // 6 is the argument passed to parameter x
		foo(y+1); // the value of y+1 is the argument passed to parameter x

	. A reference to a variable is treated exactly the same as the variable itself, any changes made to the reference are 
	  passed through to the argument!

	 . A const reference is a reference that does not allow the variable being referenced to be changed through the reference. 
	   Consequently, if we use a const reference as a parameter, we guarantee to the caller that the function will not change the argument!

	Pass by const reference:
		Using const is useful for several reasons:

	 . It enlists the compilers help in ensuring values that shouldn’t be changed aren’t changed (the compiler will throw an 
	   error if you try, like in the above example).

	 . It tells the programmer that the function won’t change the value of the argument. This can help with debugging.

	 . You can’t pass a const argument to a non-const reference parameter. Using const parameters ensures you can pass both 
	 	non-const and const arguments to the function.

	 . Const references can accept any type of argument, including non-const l-values, const l-values, and r-values.

	 . Non-const references cannot bind to r-values. A function with a non-const reference parameter cannot be called with 
	   literals or temporaries.

	Returning values by value, reference, and address:
		Return by value:
			When to use return by value:
				. When returning variables that were declared inside the function
				. When returning function arguments that were passed by value
			When not to use return by value:
				. When returning a built-in array or pointer (use return by address)
				. When returning a large struct or class (use return by reference)
		Return by address:
			When to use return by address:
				. When returning dynamically allocated memory and you can’t use a type that handles allocations for you
				. When returning function arguments that were passed by address
			When not to use return by address:
				. When returning variables that were declared inside the function or parameters that were passed by value (use return by value)
				. When returning a large struct or class that was passed by reference (use return by reference)
		Return by reference:
			When to use return by reference:
				. When returning a reference parameter
				. When returning a member of an object that was passed into the function by reference or address
				. When returning a large struct or class that will not be destroyed at the end of the function (e.g. one that was passed in by reference)
			When not to use return by reference:
				. When returning variables that were declared inside the function or parameters that were passed by value (use return by value)
				. When returning a built-in array or pointer value (use return by address)

	Inline Function:
		C++ offers a way to combine the advantages of functions with the speed of code written in-place: inline functions. The inline keyword is used
		to request that the compiler treat your function as an inline function. When the compiler compiles your code, all inline functions are expanded
		in-place -- that is, the function call is replaced with a copy of the contents of the function itself, which removes the function call overhead!
		The downside is that because the inline function is expanded in-place for every function call, this can make your compiled code quite a bit
		larger, especially if the inline function is long and/or there are many calls to the inline function.	
		eg:
			inline int min(int x, int y) {             
    			return x > y ? y : x;
			}
			Now when the program compiles main(), it will create machine code as if main() had been written like this:
			int main() {
				std::cout << (5 > 6 ? 6 : 5) << '\n';
				std::cout << (3 > 2 ? 2 : 3) << '\n';
				return 0;
			}
		. Because of the potential for code bloat, inlining a function is best suited to short functions (e.g. no more than a few lines) that are 
		  typically called inside loops and do not branch. Also note that the inline keyword is only a recommendation -- the compiler is free to ignore
		  your request to inline a function. This is likely to be the result if you try to inline a lengthy function!	

		. Be aware of inline functions, but modern compilers should inline functions for you as appropriate, so there isn’t a need to use the keyword.

	Function pointer:
		instead of pointing to variables, they point to functions!
		Synatx: int (*fcnPtr)();

		. To make a const function pointer, the const goes after the asterisk:
			int (*const fcnPtr)();
		. Assigning a function to a function pointer
			int foo() {return 5;}  int goo() {return 6;}
 
			int main() {
				int (*fcnPtr)(){ &foo }; // fcnPtr points to function foo
				fcnPtr = &goo; // fcnPtr now points to function goo
				return 0;
			}

			// function prototypes
			int foo();
			double goo();
			int hoo(int x);
			
			// function pointer assignments
			int (*fcnPtr1)(){ &foo }; // okay
			int (*fcnPtr2)(){ &goo }; // wrong -- return types don't match!
			double (*fcnPtr4)(){ &goo }; // okay
			fcnPtr1 = &hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does
			int (*fcnPtr3)(int){ &hoo }; // okay

		. Calling a function using a function pointer:	
			int (*fcnPtr)(int){ &foo }; // Initialize fcnPtr with function foo
			(*fcnPtr)(5); // call function foo(5) through fcnPtr.
		  The second way is via implicit dereference
		  	 int (*fcnPtr)(int){ &foo }; // Initialize fcnPtr with function foo
    		 fcnPtr(5); // call function foo(5) through fcnPtr.
		
		. Passing functions as arguments to other functions
			void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int));
			Calling: comparisonFcn(array[bestIndex], array[currentIndex])
		
		. Providing default functions
			void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int) = ascending);
		
		. Making function pointers prettier with type aliases:
			using ValidateFunction = bool(*)(int, int);
		
		. Using std::function:
			An alternate method of defining and storing function pointers is to use std::function, which is part of the standard library <functional>
			header. To define a function pointer using this method, declare a std::function object like so:
			eg:
				#include <functional>
				bool validate(int x, int y, std::function<bool(int, int)> fcn); //std::function method that returns a bool and takes two int parameters
	 		eg:
			 	using ValidateFunctionRaw = bool(*)(int, int); // type alias to raw function pointer
				using ValidateFunction = std::function<bool(int, int)>; // type alias to std::function

		. Type inference for function pointers:
			Much like the auto keyword can be used to infer the type of normal variables, the auto keyword can also infer the type of a function 
			pointer.
			eg:

	Ellipsis:
		.  C++ provides a special specifier known as ellipsis (aka “…”) that allow us to pass a variable number of parameters to a function.
		Syntax:
				return_type function_name(argument_list, ...)
			The argument_list is one or more normal function parameters. Note that functions that use ellipsis must have at least one non-ellipsis 
			parameter. Any arguments passed to the function must match the argument_list parameters first.
		
		. The ellipsis (which are represented as three periods in a row) must always be the last parameter in the function.
		eg:	#include <cstdarg> // needed to use ellipsis
			// The ellipsis must be the last parameter
			// count is how many additional arguments we're passing
			double findAverage(int count, ...)
			{
				double sum{ 0 };
			
				// We access the ellipsis through a va_list, so let's declare one
				va_list list;
			
				// We initialize the va_list using va_start.  The first parameter is
				// the list to initialize.  The second parameter is the last non-ellipsis
				// parameter.
				va_start(list, count);
			
				// Loop through all the ellipsis arguments
				for (int arg{ 0 }; arg < count; ++arg)
				{
					// We use va_arg to get parameters out of our ellipsis
					// The first parameter is the va_list we're using
					// The second parameter is the type of the parameter
					sum += va_arg(list, int);
				}
			
				// Cleanup the va_list when we're done.
				va_end(list);
			
				return sum / count;
			}
		. Why ellipsis are dangerous: Type checking is suspended
			With regular function parameters, the compiler uses type checking to ensure the types of the function arguments match the types of the
			function parameters (or can be implicitly converted so they match). This helps ensure you don’t pass a function an integer when it was 
			expecting a string, or vice versa. However, note that ellipsis parameters have no type declarations. When using ellipsis, the compiler 
			completely suspends type checking for ellipsis parameters. This means it is possible to send arguments of any type to the ellipsis! 
			However, the downside is that the compiler will no longer be able to warn you if you call the function with ellipsis arguments that do 
			not make sense. When using the ellipsis, it is completely up to the caller to ensure the function is called with ellipsis arguments that
			the function can handle.

		. Why ellipsis are dangerous: ellipsis don’t know how many parameters were passed
			Not only do the ellipsis throw away the type of the parameters, it also throws away the number of parameters in the ellipsis. This means
			we have to devise our own solution for keeping track of the number of parameters passed into the ellipsis. Typically, this is done in one
			of three ways.
			Method 1: Pass a length parameter
			Method 2: Use a sentinel value
			Method 3: Use a decoder string

	 Lamda Function:
	 	. A lambda expression (also called a lambda or closure) allows us to define an anonymous function inside another function. The nesting is 
	 	  important, as it allows us both to avoid namespace naming pollution, and to define the function as close to where it is used as possible 
		  (providing additional context).

		. The syntax for lambdas is one of the weirder things in C++, and takes a bit of getting used to. Lambdas take the form:

			[ captureClause ] ( parameters ) -> returnType
			{
			    statements;
			}
 
		. The capture clause and parameters can both be empty if they are not needed. The return type is optional, and if omitted, auto will be 
		  assumed (thus using type inference used to determine the return type).

		 eg:
		 	constexpr std::array<std::string_view, 4> arr{ "apple", "banana", "walnut", "lemon" };
 
			// Define the function right where we use it.
			const auto found{ std::find_if(arr.begin(), arr.end(),
		                           [](std::string_view str) // here's our lambda, no capture clause
		                           {
		                             return (str.find("nut") != std::string_view::npos);
		                           }) };


		 Types of Lamda:
		 	In the above example, we defined a lambda right where it was needed. This use of a lambda is sometimes called a function literal.
		 	we can also initialize a lambda variable with a lambda definition and then use it later. A named lambda along with a good function name
			can make code easier to read.

		 	eg:
		 		auto isEven{
				  [](int i)
				  {
				    return ((i % 2) == 0);
				  }
				};
				return std::all_of(array.begin(), array.end(), isEven);

		. In actuality, lambdas aren’t functions (which is part of how they avoid the limitation of C++ not supporting nested functions). They’re 
		  a special kind of object called a functor. Functors are objects that contain an overloaded operator() that make them callable like a 
		  function.


		 . Although we don’t know the type of a lambda, there are several ways of storing a lambda for use post-definition. If the lambda has an 
		   empty capture clause, we can use a regular function pointer. In the next lesson, we introduce lambda captures, a function pointer won’t 
		   work anymore at that point. However, std::function can be used for lambdas even if they are capturing something.

		   eg:
		   	// A regular function pointer. Only works with an empty capture clause.
			  double (*addNumbers1)(double, double){
			    [](double a, double b) {
			      return (a + b);
			    }
			  };
			 
			  addNumbers1(1, 2);
			 
			  // Using std::function. The lambda could have a non-empty capture clause (Next lesson).
			  std::function addNumbers2{ // note: pre-C++17, use std::function<double(double, double)> instead
			    [](double a, double b) {
			      return (a + b);
			    }
			  };
			 
			  addNumbers2(3, 4);
			 
			  // Using auto. Stores the lambda with its real type.
			  auto addNumbers3{
			    [](double a, double b) {
			      return (a + b);
			    }
			  };
			 
			  addNumbers3(5, 6);


		. The only way of using the lambda’s actual type is by means of auto. auto also has the benefit of having no overhead compared to 
		  std::function.

		. Unfortunately, we can’t always use auto. In cases where the actual lambda is unknown (e.g. because we’re passing a lambda to a function 
		  as a parameter and the caller determines what lambda will be passed in), we can’t use auto. In such cases, std::function should be used.

		 eg:
		 	// We don't know what fn will be. std::function works with regular functions and lambdas.
			void repeat(int repetitions, const std::function<void(int)>& fn)
			{
			  for (int i{ 0 }; i < repetitions; ++i)
			  {
			    fn(i);
			  }
			}

			repeat(3, [](int i) {
			    std::cout << i << '\n';
			  });

		. Use auto when initializing variables with lambdas, and std::function if you can’t initialize the variable with the lambda.

		. Generic lambdas:

			For the most part, lambda parameters work by the same rules as regular function parameters.
			One notable exception is that since C++14 we’re allowed to use auto for parameters (note: in C++20, regular functions will be able to use
			auto for parameters too). When a lambda has one or more auto parameter, the compiler will infer what parameter types are needed from the calls 
			to the lambda.
			Because lambdas with one or more auto parameter can potentially work with a wide variety of types, they are called generic lambdas.
			. When used in the context of a lambda, auto is just a shorthand for a template parameter.

		eg:

			constexpr std::array months{ // pre-C++17 use std::array<const char*, 12>
		    				"January", "February","March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
		  				};
 
		  // Search for two consecutive months that start with the same letter.
		  const auto sameLetter{ std::adjacent_find(months.begin(), months.end(),
		                                      [](const auto& a, const auto& b) {
		                                        return (a[0] == b[0]);
		                                      }) };

	The capture clause:
		. The capture clause is used to (indirectly) give a lambda access to variables available in the surrounding scope that it normally would not
		  have access to. All we need to do is list the entities we want to access from within the lambda as part of the capture clause.
		eg:
			std::array<std::string_view, 4> arr{ "apple", "banana", "walnut", "lemon" };
			std::string search{"nana};
			
			// Capture @search                                vvvvvv
			auto found{ std::find_if(arr.begin(), arr.end(), [search](std::string_view str) {
				return (str.find(search) != std::string_view::npos);
			}) };
		. The captured variables of a lambda are clones of the outer scope variables, not the actual variables.
		. By default, variables are captured by const value. This means when the lambda is created, the lambda captures a constant copy of the outer
		  scope variable, which means that the lambda is not allowed to modify them.
		. To allow modifications of variables that were captured by value, we can mark the lambda as mutable. The mutable keyword in this context 
		  removes the const qualification from all variables captured by value.
		  eg:
		  	int ammo{ 10 };
			auto shoot{
				// Added mutable after the parameter list.
				[ammo]() mutable {
				// We're allowed to modify ammo now
				--ammo;		
				std::cout << "Pew! " << ammo << " shot(s) left.\n";
				}
			};
		. Much like functions can change the value of arguments passed by reference, we can also capture variables by reference to allow our lambda
		  to affect the value of the argument.
		  To capture a variable by reference, we prepend an ampersand (&) to the variable name in the capture. Unlike variables that are captured by
		  value, variables that are captured by reference are non-const, unless the variable they’re capturing is const. Capture by reference should be
		  preferred over capture by value whenever you would normally prefer passing an argument to a function by reference (e.g. for non-fundamental types).
		  eg:
		  	int ammo{ 10 };
			auto shoot{
				// We don't need mutable anymore
				[&ammo]() { // &ammo means ammo is captured by reference
				// Changes to ammo will affect main's ammo
				--ammo;
			
				std::cout << "Pew! " << ammo << " shot(s) left.\n";
				}
			};			
			shoot();
		. we can use a reference capture to count how many comparisons std::sort makes when it sorts an array.
		  eg:
		  	int comparisons{ 0 };
 
			std::sort(cars.begin(), cars.end(),
				// Capture @comparisons by reference.
				[&comparisons](const auto& a, const auto& b) {
				// We captured comparisons by reference. We can modify it without "mutable".
				++comparisons;
			
				// Sort the cars by their make.
				return (a.make < b.make);
			});
  			std::cout << "Comparisons: " << comparisons << '\n';

		. Multiple variables can be captured by separating them with a comma. This can include a mix of variables captured by value or by reference:
		  eg:
		  		int health{ 33 };
				int armor{ 100 };
				std::vector<CEnemy> enemies{};
				
				// Capture health and armor by value, and enemies by reference.
				[health, armor, &enemies](){};
				
		. Default captures:
			A default capture (also called a capture-default) captures all variables that are mentioned in the lambda. Variables not mentioned in the
			lambda are not captured if a default capture is used.
			To capture all used variables by value, use a capture value of =.
			To capture all used variables by reference, use a capture value of &.
			eg:
				std::array areas{ 100, 25, 121, 40, 56 };
				int width{10};
				int height{5};
				int length=6; // will not be captured as it is not mentioned in lambda
				auto found{ std::find_if(areas.begin(), areas.end(),
							[=](int knownArea) { // will default capture width and height by value
								return (width * height == knownArea); // because they're mentioned here
							}) };

			Default captures can be mixed with normal captures. We can capture some variables by value and others by reference, but each variable can
			only be captured once.
			eg:
				int health{ 33 };
				int armor{ 100 };
				std::vector<CEnemy> enemies{};
				
				// Capture health and armor by value, and enemies by reference.
				[health, armor, &enemies](){};
				
				// Capture enemies by reference and everything else by value.
				[=, &enemies](){};
				
				// Capture armor by value and everything else by reference.
				[&, armor](){};
				
				// Illegal, we already said we want to capture everything by reference.
				[&, &armor](){};
				
				// Illegal, we already said we want to capture everything by value.
				[=, armor](){};
				
				// Illegal, armor appears twice.
				[armor, &health, &armor](){};
				
				// Illegal, the default capture has to be the first element in the capture group.
				[armor, &](){};

